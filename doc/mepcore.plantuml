@startuml
set namespaceSeparator ::

abstract class MEP::Object {
    +Object(uint id);
    +uint score();
    +uint id();
    +void assess(const Fitness&);
    +std::string write();
    -{abstract}int assess(const Fitness&);
    -{abstract}void write(std::string&);
    -uint score_;
    -uint id_;
}

abstract class MEP::Gene<Type> {
    +Gene(uint id);
    +void run(std::vector<Gene<Type>>&);
    +void clear();
    +bool isValid();
    +{abstract}uint nArguments();
    -{abstract}Type run(std::vector<Type>&)
    -void write(std::string&);
    -Type result_;
}

class MEP::Chromosome<Type> {
    +Chromosome(uint id);
    +void AddGene(Gene&)
    +void run();
    +void clear();
    +bool isCleared();
    +Tree release();
    -void write(std::string&);
    -bool is_runed_;
    -vector<Gene<Type>> genes_;
}

class MEP::Chromosome::Gene<Type> {
    +GenePtr<Type> node;
    +std::unordered_set<uint> children;
}

class MEP::FunctionGene<Type> {
    +FunctionGene(uint id);
    +uint nArguments();
    -void write(std::string&);
    -Type run(std::vector<Type>&);
    -FunctionPtr<Type> function_;
}
class MEP::TerminalGene<Type> {
    +TerminalGene(uint id);
    +uint nArguments();
    -void write(std::string&);
    -Type run(std::vector<Type>&);
    -Type terminal_;
}
class MEP::Tree<Type> {
    +Tree(uint id, Node root);
    +void release();
    -void write(std::string&);
    +Chromosome<Type> release();
    -Node<Type> root_;
}
class MEP::Node<Type> {
    +Node(GenePtr);
    +Type run();
    +std::vector<Node<Type>> children;
    -GenePtr<Type> gene_
    -~Node();
}
MEP::Object <|-- MEP::Gene
MEP::Object <|-- MEP::Chromosome

MEP::Chromosome o-- MEP::Chromosome::Gene

MEP::Chromosome::Gene o-left- MEP::Gene

MEP::Gene <|-- MEP::FunctionGene
MEP::Gene <|-- MEP::TerminalGene
MEP::Gene -[hidden]right- MEP::Chromosome
MEP::TerminalGene -[hidden]right- MEP::FunctionGene

MEP::TerminalGene <|-- MEP::Tree

MEP::Tree o-- MEP::Node

class MEP::Generator<Type> {
    +void register(FunctionPtr<Type>, double probability);
    +void register(Type terminal, double probability);
    +void register(GenePtr<Type>, double probability);
    +void reset();
    +GenePtr<Type> rand();
    -std::vector<pair<uint, GenePtr<Type>>> original_;
}

MEP::Object .. MEP::Generator

abstract class MEP::Fitness<Type> {
    +Fitness(Type reference);
    +void setReference(const Type &referece);
    +uint measure(const Type& type);
    -Type reference_;
}
MEP::Object .. MEP::Fitness
MEP::Object -[hidden]left- MEP::GeneticOperation
MEP::Object -[hidden]left- MEP::GeneticSelection

class MEP::Population<Type> {
    +Population(uint size, Type reference);
    +void setReference(const Type &referece);
    +void init();
    +void run();
    +Chromosome<Type> reproduce();
    +Generator<Type> generator;
    +GeneticOperationGenerator<Type> generator;
    -GeneticSelectionPtr<Type> generator;
    -FitnessPtr<Type> fitness;
    -std::vector<Chromosome<Type>> population_;
    -uint size_;
}
MEP::Population o-left- MEP::Chromosome
MEP::Population o-- MEP::Fitness
MEP::Population o-- MEP::Generator
MEP::Population o-up- MEP::GeneticSelection
MEP::Population o-up- MEP::GeneticOperationGenerator

@enduml